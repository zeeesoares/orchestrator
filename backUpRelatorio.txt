\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{setspace}

\setcounter{secnumdepth}{2}

\geometry{a4paper, margin=1in}

\title{\textbf{TP2 Relatório - Grupo 25}}
\author{Diogo Outeiro - a104092\\José Soares - a103995\\Nuno Melo - a104446\\}
\date{Maio 2024}

\begin{document}

\maketitle
\onehalfspacing


\bigskip
\tableofcontents
\pagebreak
\listoffigures
\pagebreak


\section{Introdução}
Este projeto tem como objetivo desenvolver um serviço de orquestração de tarefas em um sistema computacional. O propósito é permitir que os utilizadores submetam tarefas para execução em um servidor, indicando a duração estimada da tarefa e o programa ou conjunto de programas a serem executados. O servidor é responsável por escalonar e executar essas tarefas de maneira eficiente, mantendo todos os registos relevantes para análises posteriores.

Neste relatório, apresentaremos de forma sucinta a solução desenvolvida pelo nosso grupo, focando especialmente na arquitetura de processos adotada e no uso dos mecanismos de comunicação. Exploraremos como esses elementos foram fundamentais para o desenvolvimento de um sistema eficiente de orquestração de tarefas. Também ao longo deste documento, iremos justificar nossas escolhas arquiteturais e demonstrar como elas contribuíram para o sucesso do projeto.

\pagebreak
\section{Resumo}

Como já foi referido, o serviço consiste em um cliente, responsável por enviar solicitações de execução de tarefas, e um servidor, encarregado de receber essas solicitações, escalonar as tarefas e executá-las conforme necessário. 

No nosso trabalho prático implementamos cada uma das funcionalidades do enunciado, que se encontram a seguir explicadas de forma breve. Além disso, foi pedido no enunciado a execução e avaliação de eficiência do processamento de tarefas. 


\subsection{Funcionalidades Básicas Implementadas:}

\subsubsection{Execução de Tarefas do Usuário:}
\begin{itemize}
    \item Desenvolvemos um cliente capaz de receber informações do utilizador, como o tempo estimado e o programa a ser executado.
    \item Implementamos no servidor a capacidade de receber e escalonar essas tarefas, redirecionando a saída padrão e de erro para arquivos com base no identificador da tarefa.
    \item Após a conclusão da tarefa, registamos o identificador da tarefa e seu tempo de execução em um arquivo persistente.
\end{itemize}

\subsubsection{Consulta de Tarefas em Execução:}
\begin{itemize}
    \item Criamos no cliente a funcionalidade de consultar o status das tarefas em execução, em espera e concluídas.
    \item Implementamos no servidor o processamento dessas consultas, retornando as informações solicitadas ao cliente.
\end{itemize}


\subsubsection{Encadeamento de Programas e Processamento Paralelo Implementados:}
\begin{itemize}
    \item Desenvolvemos no cliente a capacidade de suportar a execução encadeada de programas (pipelines), permitindo aos utilizadores encadear vários programas em uma única tarefa.
    \item Implementamos no servidor a execução dessas pipelines de programas conforme especificado pelos utilizadores.
\end{itemize}

\subsubsection{Processamento de Várias Tarefas em Paralelo:}
\begin{itemize}
    \item No servidor, implementamos a capacidade de processar um número definido de tarefas em paralelo.
    \item O algoritmo de escalonamento foi otimizado para aumentar a velocidade de processamento das tarefas, levando em consideração o número de tarefas que podem ser executadas simultaneamente.
\end{itemize}


\subsection{Testes e Desempenho}

O projeto inclui testes para avaliar a eficiência da política de escalonamento implementada, comparando-a com outras políticas.
Testes são realizados com diferentes configurações de paralelização do servidor para compreender seu impacto na experiência do utilizador, como o tempo médio de execução das tarefas.
O relatório incluirá uma reflexão sobre os resultados dos testes realizados, bem como a utilização de scripts para automatizar os testes.

\section{Arquitetura do Projeto}

A arquitetura de processos desempenha um papel crucial no desenvolvimento de um sistema de orquestração de tarefas eficiente. Ao projetar a arquitetura do nosso sistema, foi fundamental considerar questões como concorrência, comunicação entre processos e escalonamento de tarefas. A escolha e o uso adequado dos mecanismos de comunicação são essenciais para garantir a coordenação entre os diferentes componentes do sistema.\\

Para atender aos requisitos do projeto, optamos por uma arquitetura cliente-servidor. Nessa arquitetura, o cliente é responsável por interagir com os utilizadores, enquanto o servidor é encarregado de executar e gerenciar as tarefas submetidas pelos utilizadores.

\begin{itemize}
    \item Cliente: O cliente é implementado como um processo separado que recebe as solicitações dos utilizadores e as encaminha para o servidor. Ele também é responsável por exibir a confirmação da tarefa pelo servidor. Essa abordagem permite uma separação clara de responsabilidades e facilita a modularidade do sistema.
    \item Servidor: O servidor é o núcleo do sistema, responsável por receber, escalonar e executar as tarefas submetidas pelos utilizadores. No nosso caso também gerencia o estado das tarefas e fornece informações sobre o status das tarefas em execução, em espera e concluídas. O servidor é implementado como um processo separado para garant ir que possa lidar com múltiplos clientes de forma concorrente.
\end{itemize}

De forma simples, a interação entre o cliente e o orquestrador ocorre por meio de comunicação via pipes com nome, onde para o nosso projeto, trabalhamos apenas com um FIFO que liga diretamente todos os clientes que aparecerem ao servidor, sendo este o único ponto de acesso ao orchestrator.\\

O funcionamento do nosso programa tem por base os seguintes passsos:

\begin{enumerate}
    \item O cliente inicia e recebe um argumento da linha de comando indicando a operação desejada (por exemplo, execute, status, exit).
    \item Se a operação for executar uma nova tarefa (execute), o cliente cria uma estrutura de dados contendo informações sobre a tarefa, como o tempo estimado de execução e o programa a ser executado. Essa estrutura é então enviada para o orquestrador através de um pipe com nome.
    \item O orquestrador, ao receber a solicitação do cliente, trata da receção e da decisão para saber se a tarefa deve ser executada ou posta em fila de espera.
    \item Caso a tarefa efetivamente seja para executar, ou exista uma com prioridade (definida pelo método de escalonamento) pronta para execução, é criado um novo processo encarregado de controlar a tarefa, sendo que este além de criar de novo outro processo para realmente executar o comando, também faz a espera depois para enviar ao servidor a resposta de que o comando foi executado. Assim o servidor nunca entra em bloqueio, a não ser pela leitura do fifo principal, pois para cada tarefa é feito um processo á parte para o tratamento de cada tarefa em específico. 
    \item Na parte da execução real do comando passado pelo utilizador são feitos todos os redirecionamentos, escritas  e medidas de tempo necessárias e assim é concluído o processo para o comando inicial.
\end{enumerate}

Essa interação permite que o cliente envie solicitações ao orquestrador para executar tarefas ou verificar o status das tarefas em execução. O orquestrador, por sua vez, gerencia a execução das tarefas e fornece feedback ao cliente conforme necessário (identificador ou status).


Na figura seguinte temos uma representação básica do funcionamento do nosso programa, onde cada retângulo representa um processo.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{images/arq.drawio.png}
    \caption{Arquitetura Básica}
    \label{fig:enter-label}
\end{figure}


\subsection{Arquetetura de Processos}

Na função \texttt{dispatch}, um processo filho é criado utilizando a chamada de sistema \texttt{fork()}. Dentro deste processo filho, a função \texttt{exec\_function} é chamada para executar a tarefa solicitada. Após a execução da função \texttt{exec\_function}, o processo filho termina sua execução utilizando \texttt{\_exit()}. Isso garante que o processo pai (o orquestrador) não seja bloqueado pela execução do filho.

Na função \texttt{handle\_tasks} do orquestrador, quando uma nova tarefa é recebida, o orquestrador verifica se o número de tarefas em execução é menor que o número máximo permitido de tarefas em paralelo. Se for o caso, o orquestrador cria um novo processo filho para executar a tarefa. Este processo filho, por sua vez, executa a função \texttt{dispatch} para executar a tarefa solicitada. Assim, o orquestrador não fica bloqueado enquanto espera pela conclusão da execução da tarefa, pois delega essa responsabilidade para os processos filhos.

Além disso, é importante observar que, após a execução da tarefa, o processo filho termina sua execução utilizando \texttt{\_exit()}, garantindo que recursos do sistema sejam adequadamente libertados e que o processo pai não seja bloqueado pela execução do filho.

Dessa forma, tanto na função \texttt{dispatch} quanto na função \texttt{handle\_tasks}, a construção de processos é realizada de forma a garantir que o servidor nunca fique bloqueado enquanto espera pela conclusão das tarefas executadas pelos processos filhos.

Na representação seguinte temos de forma simples todo o processo pensado para conceber a construção de processos.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\linewidth]{images/arcP.drawio.png}
    \caption{Arquitetura de Processos}
    \label{fig:enter-label}
\end{figure}

\subsection{Mecanismos de Comunicação}

No âmbito da comunicação entre cliente e servidor, optamos pelo uso de pipes nomeados. Os pipes nomeados oferecem uma forma eficiente e bidirecional de troca de dados entre processos independentes. Essa escolha permite uma comunicação assíncrona e sincronizada entre o cliente e o servidor, garantindo uma interação eficiente e coordenada.

\subsubsection{Criação dos Pipes Nomeados}
No início do código do cliente e do servidor, há chamadas para criar pipes nomeados. Por exemplo, no servidor, é criado apenas um pipe nomeado chamado \texttt{MAIN\_FIFO\_SERVER}. Isso é feito pela função \texttt{make\_fifo} nos dois processos.

\subsubsection{Abertura dos Pipes Nomeados}
O cliente e o servidor abrem os pipes nomeados para leitura e escrita. No servidor, o pipe é aberto com permissões de leitura e escrita (\texttt{O\_RDONLY} e \texttt{O\_WRONLY}), e isto dá se para nunca existir o problema de EOF (End of File) a quando da submissão de tarefas. No cliente, pipe nomeado chamado \texttt{MAIN\_FIFO\_SERVER} é aberto principalmente para escrita (\texttt{O\_WRONLY}) e depois é aberto um pipe nomeado respetivo ao seu processo  \texttt{FIFO\_PID} para envio do identificador de tarefa por parte do servidor. Isso é feitoatravés da função \texttt{open\_fifo}.

\subsubsection{Escrita nos Pipes Nomeados}
No cliente, após a preparação dos dados da tarefa, eles são escritos no pipe nomeado usando a função \texttt{write}. Por exemplo, quando o cliente solicita a execução de uma nova tarefa, ele escreve os dados da tarefa no pipe nomeado \texttt{MAIN\_FIFO\_SERVER}.

\subsubsection{Leitura nos Pipes Nomeados}
No servidor, há um loop infinito que lê continuamente os dados do pipe nomeado. Isso é feito usando a função \texttt{read}. Quando o servidor recebe os dados da tarefa, é responsável por processar o pedido conforme necessário.\\

Esses mecanismos de comunicação garantem que o cliente possa enviar solicitações de tarefa para o servidor de forma eficiente, e o servidor possa coordenar a execução dessas tarefas de maneira sincronizada e coordenada. Os pipes nomeados oferecem uma maneira robusta e eficiente de troca de dados entre processos independentes, contribuindo para a eficiência  do sistema de orquestração.

\pagebreak
\section{Avaliação de Políticas de Escalonamento}

Nesta seção, apresentamos a avaliação de duas políticas de escalonamento implementadas no sistema: First-Come, First-Served (FCFS) e Shortest Job First (SJF). Essas políticas determinam a ordem de execução das tarefas com base em diferentes critérios, o que pode influenciar o desempenho e o tempo de resposta do sistema.

\subsection{First-Come, First-Served (FCFS)}

A política FCFS é uma das políticas de escalonamento mais simples, em que as tarefas são executadas na ordem em que foram recebidas pelo servidor. Isso significa que a primeira tarefa a chegar é a primeira a ser executada, independentemente da sua duração ou exigência de recursos. A simplicidade desta política pode ser uma vantagem em cenários de baixa carga, mas pode levar a longos tempos de espera para tarefas grandes ou de longa duração.

\subsection{Shortest Job First (SJF)}

A política SJF prioriza a execução das tarefas mais curtas primeiro. Isso significa que, entre todas as tarefas pendentes, a que possui o menor tempo de execução é selecionada para execução em seguida. Essa política visa minimizar o tempo médio de espera das tarefas na fila e pode ser especialmente eficaz em situações em que há uma grande variação no tempo de execução das tarefas.

\subsection{Testes e Avaliação}

Foram realizados testes para avaliar o desempenho das políticas FCFS e SJF em diferentes cenários de carga de trabalho e tipos de tarefas. A seguir, enumeramos os resultados obtidos durante os testes:

\begin{enumerate}
    \item Tempo médio de espera das tarefas em cada política.
    \item Tempo total de execução das tarefas em cada política.
    \item Número de tarefas completadas em um determinado período de tempo.
    \item Comparação do desempenho das políticas sob diferentes cargas de trabalho.
\end{enumerate}

Esses resultados nos permitirão avaliar a eficácia das políticas de escalonamento implementadas e identificar possíveis áreas de melhoria no sistema de orquestração de tarefas.


\end{document}

